title: VMStat 初体验
tags: backend vmstat
category: backend
date: 2015-05-15
---


当你的Windows连续开机一个星期时，你是不是发现机器特别慢，点啥啥不开。但是你去看资源管理器的又发现内存占用也没有到90%，CPU也没跑满。那为什么这个时候会那么卡呢？

其中一个原因就是由于长期使用机器且没有关机，导致内存中缓存了大量的数据。由于系统的虚拟内存管理，当内存使用达到一定程度时，系统会将内存中
的数据交换到硬盘中，也就是Windos的虚拟内存，在Linux中叫Swap分区。此时如果要使用交换到硬盘上的数据，那么系统首先要把内存中最远最久没有
使用的数据交换到硬盘，再把硬盘中需要的数据加载到内存，然后才可以跑逻辑，这样就造成了“点啥啥不开”的残像了。

那么这样的情况会不会发生在我们的Server端Linux上呢？答案当然是肯定的。而且一旦该情况发生，有可能产生雪崩效应，一下就把服务器弄回老家了。
这里的典型案例就有云风大大遇到的[Redis转储](http://blog.codingnow.com/2014/03/mmzb_redis.html)。又或者可以自己手写一个无限分配
内存并使用的例子。然后静静等待系统挂掉的那一刻。

那么什么时候会发生这样的情况？或者说当我们的系统表现出什么的症状时我们要考虑这样的情况？如何进行确诊？

一般当系统频繁的需要新内存时可能发生这样的情况，如频繁的读文件而不释放、网络接收大量文件写磁盘（写磁盘跟不上内存从网络接收的量）。此时我们的系统
对外相应速度会急剧下降但是CPU又没有跑满。这时我们就应该考虑是不是虚拟内存频繁交换的问题了。通过使用vmstat可以帮助我们来确诊是不是这个原因。

##1. vmstat输出
裸奔运行vmstat命令，可以看到一行输出。该行输出内容表示的自系统最近启动后虚拟内存和CPU的平均情况。
在输出的第一行我们称之为表头。依次包含了：

    procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
    
几个字段，第二行我们称之为子表头，依次包含了：
    
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     
其意义分别为：

1. procs : 使用内存IO的进程统计
    * r : 获取了IO资源而等待cpu运行的进程数目
    * b :　因为等待ＩＯ资源而阻塞休眠的进程数目
    
2. memory: 虚拟内存相关统计
    * swpd : 用掉的虚拟内存大小。也就是交换分区内用掉的大小
    * free : 空闲的内存大小。
    * buff ： 被用作系统buffer的大小。比如write系统调用的时候，系统不会立马写磁盘，而是先缓冲到buffer中然后在合适的时候写入磁盘。
    * cache ： 被用作系统cache的大小。

这里，free的大小表示一定可以使用的大小，即malloc不会出错的大小。但是超过free时malloc会一定出错么？也不一定。因为系统的buff和cache在必要
的时候也会优先给malloc使用。只有在不可使用时才会出错，如被设置为共享内存。因此观察时要综合这四个位置一起作判断。当分配内存时首先使用free,free不够的时候从buff和cache中匀得，当还不够时选择从swap分区中取得。

3.  swap: 交换分区的使用情况
    * si : 每秒从硬盘中交换到内存中的大小。
    * so ：每秒从内存中交换到硬盘中的大小。

4. io :  块设备IO统计
    * bi : 每秒从块设备读入内存的大小
    * bo ： 每秒从内存中写入快设备的大小
    
什么是块设备？Linux下的设备主要分成字符设备和块设备（可以参考LDD《linux device driver》），类似于Socket属于流设备，而磁盘一般属于块设备。因此这个参数可以用来衡量写磁盘的性能。

5. system　: 操作系统中断和上下文切换统计
    * in :　操作的系统每秒触发的中断数目
    * cs ： 操作系统每秒上下文切换次数，这里上下文切换可以认为是系统态到用户态或者反过来的切换

6. cpu： cpu相关统计
    * us : 用户态代码执行占用的cpu时间。
    * sy ：系统态代码执行占用的cpu时间。
    * id ： cpu空闲时间，也就是执行系统idle的时间，cpu是不可能停机的。
    * wa ： 耗费在等待IO上的时间
    * st ： 其他的等待时间。

##2. vmstat的使用

上面我们裸跑vmstat就可以得到一个输出，表示的是：自系统最近启动后虚拟内存和CPU的平均情况。

vmstat的调用格式为:

    vmstat delay count [options]

这里先介绍一个“-a”选项。
如果使用了 “-a” 选项，我们会发现其输出和上面描述的有点不一样。在memory的下面，没有了buff和cache子列了，取而代之的是inact和active子列。
他们分别表示激活的和非激活的内存大小。那怎样理解“激活”呢？对比增加了-a选和没有增加-a选项的结果我们可以发现inact + active = cache大小。
也就是我们上面讨论，如果系统中free的内存不够了，那么就去用cache和buff里面的内存。但是并不是都可以用的，其中可以用的就是inact部分。因此
我们可以知道，系统此时还可以使用的内存大小为 free+inact大小。如果该和持续下降，那么我们就要注意了。是不是有内存泄露、或者内存分配洪请求等
情况的出现了。

除此之外还有个"-d"选项
通过使用“-d”选项，可以仅查看写磁盘的性能。有一级表头 disk， reads， writes， IO四大块。disk表示的是分区名称。reads和writes分别表示
读写扇区数目。其中都有： total merged sectors  ms ：
* total   : 总共读取/写入成功的数目
* merged  : 合在一起读取操作的数目
* sectors ：读取/写入成功的扇区数目
* ms      ：一次读或者写耗费的时间，单位是毫秒

IO中包含了cur表示当前正在处理的IO数目，s表示每处理一个IO请求耗费的时间，单位是秒。
“-d”选项中包含了很多ram开头的随机分区。为了更清楚的查看可以使用
“-p”选项 指定某个分区。如 ：

    vmstat -dp /dev/sda1
    
可以仅查看该分区硬盘的读写情况。

