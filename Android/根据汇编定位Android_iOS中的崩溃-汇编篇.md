#根据汇编定位Android/iOS中的崩溃-汇编篇
### 2.1 主要寄存器


### 2.2 经典寻址方式

对数据的操作的操作就只有两个地方：寄存器和内存。那么取哪个寄存器/内存位置的数据，存放到哪里？这里ARM定义了一套寻址的规则，用来确定到底操作哪里的数据。

名称|示例代码|代码解释
---|---|-------
寄存器直接寻址| MOV R0, R1 | 将R1寄存器中的数存入到R0中
直接寻址|LDR R0, #0x0088 | 将内存地址0x0088中的数载入到内存中
立即数寻址|MOV R0, #15 | 将15放入寄存器R0中
寄存器间接寻址|LDR R0, [R1] | 将寄存器R1中的数表示的内存地址所指向的值加载进R0寄存器
寄存器带有偏移的间接寻址 | LDR R0, [R1, #4] | 将寄存器R1里的值加上4之后得到的地值表示的字为单位所指向内存值加载进R0寄存器
pre-index 寄存器带有偏移的间接寻址|LDR R0, [R1, #4]! | 将寄存器R1里的值加上4之后得到的地值表示的字为单位所指向内存值加载进R0寄存器，同时将R1寄存器中的值增加4
post-index 寄存器间接寻址|LDR R0, [R1], #4 | 将寄存器R1里的值表示的字为单位所指向内存值加载进R0寄存器，同时将R1寄存器中的值增加4

#### 寄存器间接寻址
所谓间接寻址就是先要从某个位置（寄存器）中取得一个地址，然后再到这个地址对应的内存位置取数据。
就像C中的“*”间接引用一样。所以看到这中代码，一般可以想到对应到C/CPP中有解引用的操作如

    pointer->name;
    (*pointer).name;
    
这里再举两个例子：
    
    LDR R0, [R1] ; 将寄存器R1中数值表示的字为单位的内存地址中数加载R0寄存器中
    STR	R2, [R3] ; 将R2寄存器中的数存入到R3寄存器中数值表示的字单位的内存中

#### 寄存器带有偏移的间接寻址

`间接`表示要先去一个地方取得一个地址，`偏移`是说这个取地址的地方是相对于某个位置的偏移后的地方。与上面的却别就在于，先取得寄存器中存放的数，然后以这个数位
基础再增加一个偏移量，表示目的操作内存的地址。可以联想到C/CPP中对指针做操作后再解引用，如：
    
    int i = (pointer + 2)->id;
    int j = (*(pointer + 2)).id;

再看两个例子：

    LDR R0, [R1, #20]	; 将寄存器R1里的值加上20之后得到的地值表示的字为单位所指向内存值加载进R0寄存器
    STR R0, [R1, #20]	; 将寄存器R1中的值存入寄存器R1里的值加上20之后得到的地值表示的字为单位所指向内存

#### pre-index 寄存器带有偏移的间接寻址
寄存器间接寻址我们上面解释清楚了，那么这里的pre-index表示什么呢?在C/CPP中有自增操作符，其写在变量前面和后面的效果是不一样的。pre-index就相当于“++i”，
先计算偏移后的地址。

    LDR R0, [R1, #20]!	; 将寄存器R1里的值加上20之后得到的地值表示的字为单位所指向内存值加载进R0寄存器,同时将R1寄存器中的数加20
    STR R0, [R1, #20]!	; 将寄存器R1中的值存入寄存器R1里的值加上20之后得到的地值表示的字为单位所指向内存,同时将R1寄存器中的数加20
    

#### post-index 寄存器间接寻址
C/CPP中的自增运算符还有种写法“i++”，此时先访问i后对i做自增运算。汇编中也是如此顺序进行计算：

    LDR R0, [R1, #20]!	; 将寄存器R1里的值表示的字为单位所指向内存值加载进R0寄存器,同时将R1寄存器中的数加20
    STR R0, [R1, #20]!	; 将寄存器R1中的值表示的字为单位所指向内存,同时将R1寄存器中的数加20
    


###2.3 经典指令

ARM汇编那么多指令，还分ARMv6/Thumb等种类，那么多指令如何记忆呢？


